function [v1vec, v2vec] = lambert2(mu, r1vec, r2vec, tof, directtorbit, N, x1)% Superior Lambert Algorithm to find velocity given time of flight% Computes velocity at both points of an orbit given the time of flight and% position vectors of the orbit.% % @arg% mu    - double%         Gravitational Constant% r1vec - 3 x 1 double matrix%         Start point Position vector% r2vec - 3 x 1 double matrix%         Destination point position vector% tof   - double%         Time of flight% N     - int%         Number of orbits to do. (N = 0 only for hyperbolic orbits)% x1    - double%         Initial guess parameter% % @return% v1vec - 3 x 1 double matrix%         Start point velocity vector% v2vec - 3 x 1 double matrix%         Destination point velocity vector% % @author: Matt Marti% @date: 2019-03-25error('Bad news bears: DerAstrodynamic''s algorithm is wrong!');if nargin == 0    Test_lambert2end% Check inputsassert(length(r1vec) == 3, 'incorrect size of position vector');assert(length(r2vec) == 3, 'incorrect size of position vector');assert(tof >= 0, 'Negative time of flight');assert(N >= 0, 'Undefined behavior for negative N');% Prelmininary stepalpha = dot([0;0;1], cross(r1vec,r2vec));% Step 1: Compute transfer angler1 = norm(r1vec);r2 = norm(r2vec);psi0 = acos(dot(r1vec,r2vec) / (r1*r2));psi = psi0;if directtorbit % If direct transfer    if alpha < 0        psi = 2*pi - psi0;    endelse % Retrograde transfer    if alpha > 0        psi = 2*pi - psi0;    endend% 2. Normalized timec = norm(r1vec - r2vec);m = r1 + r2 + c;n = r1 + r2 - c;tau = 4 * tof * sqrt(mu / m^3);% Angle parameter from Equation 6sigmasq = 4*r1*r2/m^2 * cos(0.5*psi)^2;sigma = sqrt(sigmasq);if pi < psi && psi < 2*pi    sigma = - sigma;elseif psi == pi    sigma = 0;end    % % 3. Parabolic normalized time% tau_p = 2/3 * ( 1 - sigma^3 );% % % 4. Determine orbit type% orbit_type_flag = tau > tau_p;% % % 5. Compute maximum number of possible revolutions% if orbit_type_flag % if is elliptic%     Nmax = round(tau / pi);%     nrev = 0;%     if Nmax >= 1%         %         % 6. Multi-revolutions compute normalized min tof%         tau_MT = 2/3 * (1/x_MT - sigma^3/abs(y_MT));%     end% end% 7. Normalized min energy timetau_ME = N*pi + acos(sigma) + sigma*sqrt(1-sigma^2);% 8. Compute starting guess x1if nargin < 7    x1 = 0.5 * tau_ME * (tau_ME/tau - 1);    if abs(x1) >= 1        x1 = 0.5;    endend% Iterative process to compute x[x, y] = lambert2_solver_subroutine(x1, r1, r2, m, psi, tau, sigma, N);% 9. Determine output velocities from converged x and yecvec = (r2vec - r1vec) / c;er1vec = r1vec / r1;er2vec = r2vec / r2;vc = sqrt(mu) * (y/sqrt(n) + x/sqrt(m));vr = sqrt(mu) * (y/sqrt(n) - x/sqrt(m));v1vec = vc * ecvec + vr * er1vec;v2vec = vc * ecvec + vr * er2vec;endfunction [x, y] = lambert2_solver_subroutine(x1, r1, r2, m, psi, tau, sigma, N)% Iterates to x and y solution% Equation 8if sigma > 0    y = @(x) sqrt(1 - sigma^2*(1-x^2));elseif sigma < 0    y = @(x) - sqrt(1 - sigma^2*(1-x^2));else    y = 1;end% % Equation 4% dx = 1e-6;% F = @(x) phi(x) + phi(y(x)) + N*pi - tau;% Fp = @(x) (F(x+dx)-F(x-dx))/(2*dx);% Fpp = @(x) (Fp(x+dx)-Fp(x-dx))/(2*dx);% % Equation 11 and 12 (the derivative) for N > 1% bigphi = @(x) phi(y(x)) - phi(x) - N*pi;% dbigphidx = @(x) 2/3 * (((1 - x^2)^1.5)/(x^2)) * (1 - sigma^5*x^3/abs(y^3));xn = x1;for i = 1:100        % Compute function values at xn%     Fn = F(xn);%     Fpn = Fp(xn);%     Fppn = Fpp(xn);    [Fn, Fpn, Fppn] = lambert_equation_subroutine(xn, y, tau, sigma, N);        % Compute change in x    deltax = deltax_laguerre_method(Fn,Fpn,Fppn);        % Increment x    xnp1 = xn + deltax;        if ~isreal(xnp1)        5;    end        % Termination criteria    err = abs(xnp1 - xn) / abs(xn);    if err < 1e-12        break;    end        % Iterate    xn = xnp1;endx = xnp1;% Compute yy = y(x);endfunction [F, Fp, Fpp] = lambert_equation_subroutine(x, y_x, tau, sigma, N)% Compute y valuey = y_x(x);if abs(x) < 1 % If elliptic        % Terms    omxsq = 1 - x^2;    omysq = 1 - y^2;    sqrtomxsq = sqrt(omxsq);    sqrtomysq = sqrt(omysq);        % Lambert Equation A1    F = (1/sqrtomxsq^3) * (...        - acot(x/sqrtomxsq) ...        + acot(y/sqrtomysq) ...        + sqrt(abs(x*omxsq)) ...        - sqrt(abs(y*omysq)) ...        + N*pi ...        - tau);    %     % Lambert Equation A1%     F = (1/sqrtomxsq^3) * (...%         - acot(x/sqrtomxsq) ...%         + acot(y/sqrtomysq) ...%         + sqrt(abs(x*omxsq)) ...%         - sqrt(abs(y*omysq)) ...%         + N*pi ...%         - tau);    elseif x > 1 % If hyperbolic        % Terms    xsqmo = x^2 - 1;    ysqmo = y^2 - 1;    sqrtxsqmo = sqrt(xsqmo);    sqrtysqmo = sqrt(ysqmo);        % Lambert Equation A2    F = (1/sqrtxsqmo^3) * (...        - acoth(x/sqrtxsqmo) ...        + acoth(y/sqrtysqmo) ...        + sqrt(abs(x*xsqmo)) ...        - sqrt(abs(y*ysqmo)) ...        - tau);else % Parabolic        % Lambert Equation A3    F = 2/3 * (1 - sigma^3) - tau;end% Derivativesomxsq = 1 - x^2;absy = abs(y);Fp = 1/omxsq * (3*x*tau - 2*(1-sigma^3)*x/absy);Fpp = 1/(x*omxsq) * ( (1+4*x^2)*Fp + 2*(1-sigma^5)*x^3/absy^3 );endfunction deltax = deltax_laguerre_method(F,Fp,Fpp)% Equation 5: Delta x step for Laguerre Method% Step size degreen = 2; % TODO: Make this an input parameter for the whole function% Sign ambiguitys = 1;if Fp < 0    s = -1;end% Function stepdeltax = - n*F / (Fp + s*sqrt( (n-1)^2*Fp^2 - n*(n-1)*F*Fpp ));endfunction [p] = phi(u)% Equation 13usq = u^2;sqrtonemusq = sqrt(1-usq);p = acot(u/sqrtonemusq) - 1/(3*u)*(2+usq)*sqrtonemusq;end