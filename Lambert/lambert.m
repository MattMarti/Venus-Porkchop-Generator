function [v1vec, v2vec] = lambert(mu, r1vec, r2vec, tof, ccwflag, tol, K)% Lambert Algorithm to find velocity given time of flight% Computes velocity at both points of an orbit given the time of flight and% position vectors of the orbit.% % Based on the algorithm presented by Bate in "Fundamentals of% Astrodynamics", 1971.% % Note that on page 236 of Bate, there is an error in the formulas for the% derivatives of C(z) and S(z) (Eqn 5.3-24 and 5.3-25, respectively). The% first term of the series expressions are positive in the derivatives,% when they should be negative. This code implements the derivatives% correctly.% % TODO: Test this function on a parabolic trajectory to make sure my% correction is actually correct.% % Also uses the DerAstrodynamics algorithm for determining whether the % transfer orbit has a change in true anomoly of greater than 180 degrees.% This function assumes planetary orbits are counter-clockwise% % @arg% mu        - double%             Gravitational Constant% r1vec     - 3 x 1 double matrix%             Start point Position vector% r2vec     - 3 x 1 double matrix%             Destination point position vector% tof       - double%             Time of flight% ccwflag   - bool (optional)%             Counter-clockwise orbit flag. True will cause the function to%             compute a counter-clockwise transfer orbit.%             Defaults to true if not specified.% tol       - double (optional)%             Eccentricity tolerance to for series solution to parabolic%             orbit% K         - int (optional)%             Maximum number of iterations% % @return% v1vec     - 3 x 1 double matrix%             Start point velocity vector% v2vec     - 3 x 1 double matrix%             Destination point velocity vector% % @author: Matt Marti% @date: 2019-03-26% Constantsconstants;tolz = PARABOLIC_TOLERANCE_LAMBERT;% Input checkingif nargin < 5    ccwflag = 1;endif nargin < 6    tol = 1e-9;endif nargin < 7    K = 16;endassert(numel(K) == 1, 'Incorrect size of argument ''K''');assert(numel(tol) == 1, 'Incorrect size of argument ''tol''');assert(tol > 0, 'tol must be positive');assert(size(r1vec,1) == 3 && size(r1vec,2) == 1, ...    'Incorrect size of argument ''r1vec''');assert(size(r2vec,1) == 3 && size(r2vec,2) == 1, ...    'Incorrect size of argument ''r2vec''');assert(numel(tof) == 1, 'Incorrect size of argument ''tof''');assert(numel(mu) == 1, 'Incorrect size of argument ''mu''');assert(numel(K) == 1, 'Incorrect size of argument ''K''');% Compute normsr1 = norm(r1vec);r2 = norm(r2vec);% Compute geometry parameteralpha = dot([0;0;1], cross(r1vec,r2vec)); % DerAstrodynamics clockwise orbitcosdelnu = dot(r1vec,r2vec) / (r1*r2);% delnu = acos(cosdelnu);DM = 1;if ccwflag % If counter-clockwise    if alpha < 0 % Long way%         delnu = 2*pi - delnu;        DM = -1;    endelse % Clockwise transfer    if alpha > 0 % Long way%         delnu = 2*pi - delnu;        DM = -1;    endend% sindelnu = sin(delnu);% A = sqrt(r1*r2)*sindelnu / sqrt(1 - cosdelnu); % Bate 5.3-7A = DM*sqrt(r1*r2*(1+cosdelnu)); % Bate 5.3-27% Initial Guessz = 0;% Lambert solution with Halley's Method Iterationi = 0;sqrtmu = sqrt(mu);oosqrtmu = 1/sqrtmu;sqrtmutof = sqrtmu*tof;while i < IMAX_LAMBERT        % Evaluate S and C    C = C_func(z, tolz, K); % Bate 4.4-10    S = S_func(z, tolz, K); % Bate 4.4-11        % S and C derivatives    dCdz = dCdz_func(z, C, S, tolz, K);    dSdz = dSdz_func(z, C, S, tolz, K);    % Determine auxiliary variable    oosqrtC = 1 / sqrt(C);    y = r1 + r2 - A*(1-z*S) * oosqrtC; % Bate 5.3-9    % Determine x    x = sqrt(y)*oosqrtC; % Bate 5.3-10    % Compute sqrt(m) times Time of Flight    ooC = 1/C;    sqrty = sqrt(y);    sqrtmudtdz = x^3*(dSdz - 1.5*S*dCdz*ooC) ...        + 0.125*A*(3*S*sqrty*ooC + A/x); % Bate 5.3-23    sqrtmut = x^3*S + A*sqrty;        % Increment z    terri = sqrtmutof - sqrtmut;    deltaz = sqrtmudtdz .\ terri;    z = z + deltaz;    %     % Compute t%     t = sqrtmut * oosqrtmu;%     dtdz = sqrtmudtdz*oosqrtmu;%     %     % Increment z%     terri = tof - t;%     deltaz = dtdz .\ terri;%     z = z + deltaz;        % End condition    if abs(deltaz/z) < tol, break; end        % Iterate    i = i + 1;end% Evaluate Lagrange parametersf = 1 - y/r1; % Bate 5.3-13g = A * sqrty/sqrtmu;% Bate 5.3-14gdot = 1 - y/r2; % Bate 5.3-15% Evaluate velocity vectorsoog = 1/g;v1vec = oog*(r2vec - f*r1vec); % Bate 5.3-16v2vec = oog*(gdot*r2vec - r1vec); % Bate 5.3-17endfunction [ Chist ] = C_func( zhist, tol, K ) % Bate 4.4-10Chist = zeros(size(zhist));for i = 1:length(zhist)    z = zhist(i);    if z <= - tol % Elliptical orbit        Chist(i) = (1 - cos(sqrt(z))) ./ z;    elseif tol <= z % Hyperbolic orbit        Chist(i) = (1 - cosh(sqrt(-z))) ./ z;    else % Parabolic orbit        Chist(i) = 0;        for k = 0:K            Chist(i) = Chist(i) + (-z).^k ./ factorial(2*k+2);        end    endendendfunction [ Shist ] = S_func( zhist, tol, K ) % Bate 4.4-11Shist = zeros(size(zhist));for i = 1:length(zhist)    z = zhist(i);    if z <= - tol % Elliptical orbit        sqrtz = sqrt(z);        Shist(i) = (sqrtz - sin(sqrtz))./(sqrtz.^3);    elseif tol <= z % Hyperbolic orbit        sqrtmz = sqrt(-z);        Shist(i) = (sinh(sqrtmz) - sqrtmz)./(sqrtmz.^3);    else % Parabolic orbit        Shist(i) = 0;        for k = 0:K            Shist(i) = Shist(i) + (-z).^k ./ factorial(2*k+3);        end    endendendfunction [ dCdz ] = dCdz_func( z, C, S, tol, K )if tol <= z || z <= - tol % Elliptical or Hyperbolic orbit    dCdz = 0.5*(1 - z*S - 2*C)/z; % Bate 5.3-21else % Parabolic orbit    dCdz = - 1/factorial(4);    for k = 1:K        dCdz = dCdz + (k+1)*(-1)^(k-1)*z^k ./ factorial(2*k+4);    endendendfunction [ dSdz ] = dSdz_func( z, C, S, tol, K )if tol <= z || z <= - tol % Elliptical or Hyperbolic orbit    dSdz = 0.5*(C - 3*S)/z; % Bate 5.3-20else % Parabolic orbit    dSdz = - 1/factorial(5);    for k = 1:K        dSdz = dSdz + (k+1)*(-1)^(k-1)*z^k ./ factorial(2*k+5);    endendend