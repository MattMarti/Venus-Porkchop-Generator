function [v1vec, v2vec] = lambert(mu, r1vec, r2vec, tof, ccwflag, tol, K)% Lambert Algorithm to find velocity given time of flight% Computes velocity at both points of an orbit given the time of flight and% position vectors of the orbit.% % Based on the algorithm presented by Bate in "Fundamentals of% Astrodynamics", 1971.% % Note that on page 236 of Bate, there is an error in the formulas for the% derivatives of C(z) and S(z) (Eqn 5.3-24 and 5.3-25, respectively). The% first term of the series expressions are positive in the derivatives,% when they should be negative. This code implements the derivatives% correctly.% % TODO: Test this function on a parabolic trajectory to make sure my% correction is actually correct.% % Also uses the DerAstrodynamics algorithm for determining whether the % transfer orbit has a change in true anomoly of greater than 180 degrees.% This function assumes planetary orbits are counter-clockwise% % @arg% mu        - double%             Gravitational Constant% r1vec     - 3 x 1 double matrix%             Start point Position vector% r2vec     - 3 x 1 double matrix%             Destination point position vector% tof       - double%             Time of flight% ccwflag   - bool (optional)%             Counter-clockwise orbit flag. True will cause the function to%             compute a counter-clockwise transfer orbit.%             Defaults to true if not specified.% tol       - double (optional)%             Eccentricity tolerance to for series solution to parabolic%             orbit% K         - int (optional)%             Maximum number of iterations% % @return% v1vec     - 3 x 1 double matrix%             Start point velocity vector% v2vec     - 3 x 1 double matrix%             Destination point velocity vector% % @author: Matt Marti% @date: 2019-03-26% Constantsconstants;tolz = PARABOLIC_TOLERANCE_LAMBERT;% Input checkingif nargin < 5    ccwflag = 1;endif nargin < 6    tol = 1e-9;endif nargin < 7    K = 16;endassert(numel(K) == 1, 'Incorrect size of argument ''K''');assert(numel(tol) == 1, 'Incorrect size of argument ''tol''');assert(tol > 0, 'tol must be positive');assert(size(r1vec,1) == 3 && size(r1vec,2) == 1, ...    'Incorrect size of argument ''r1vec''');assert(size(r2vec,1) == 3 && size(r2vec,2) == 1, ...    'Incorrect size of argument ''r2vec''');assert(numel(tof) == 1, 'Incorrect size of argument ''tof''');assert(numel(mu) == 1, 'Incorrect size of argument ''mu''');assert(numel(K) == 1, 'Incorrect size of argument ''K''');% Compute normsr1 = norm(r1vec);r2 = norm(r2vec);% Compute geometry parameteralpha = dot([0;0;1], cross(r1vec,r2vec)); % DerAstrodynamics clockwise orbitcosdelnu = dot(r1vec,r2vec) / (r1*r2);% delnu = acos(cosdelnu);DM = 1;if ccwflag % If counter-clockwise    if alpha < 0 % Long way%         delnu = 2*pi - delnu;        DM = -1;    endelse % Clockwise transfer    if alpha > 0 % Long way%         delnu = 2*pi - delnu;        DM = -1;    endendA = DM*sqrt(r1*r2*(1+cosdelnu)); % Bate 5.3-27% Initial Guesssqrtmu = sqrt(mu);oosqrtmu = 1/sqrtmu;sqrtmutof = sqrtmu*tof;z = 0;[T, Tp, Tpp] = tof_func(z, sqrtmutof, r1, r2, A, tolz, K);% Lambert solution with Halley's Method Iterationi = 0;while i < IMAX_LAMBERT        % Newton's Method    deltaz_1 = - T ./ Tp;    z_1 = z + deltaz_1;        % Halley's Method    deltaz_2 = - (T.*Tp) ./ (Tp.^2 - 0.5*T.*Tpp);    z_2 = z + deltaz_2;        % Compute time of flight using both methods    [T_1, Tp_1, Tpp_1] = tof_func(z_1, sqrtmutof, r1, r2, A, tolz, K);    [T_2, Tp_2, Tpp_2] = tof_func(z_2, sqrtmutof, r1, r2, A, tolz, K);        % Step size halving to prevent overshoot    alpha = 1;    j = 0;    while j < HALVINGMAX_LAMBERT ...            && (abs(T_2) >= abs(T) && abs(T_1) >= abs(T))                % Half step Newton        z_1 = z + alpha*deltaz_1;        [T_1, Tp_1, Tpp_1] = tof_func(z_1, sqrtmutof, r1, r2, A, tolz, K);                % Half step Halley        z_2 = z + alpha*deltaz_2;        [T_2, Tp_2, Tpp_2] = tof_func(z_2, sqrtmutof, r1, r2, A, tolz, K);                % Iterate        alpha = 0.5*alpha;        j = j + 1;    end        % Decide between using the two methods    if max(abs(T_2)) <= max(abs(T_1)) % Choose Halley's Method        T = T_2;        Tp = Tp_2;        Tpp = Tpp_2;        deltaz = deltaz_2;        z = z_2;    else % Choose Newton's Method        T = T_1;        Tp = Tp_1;        Tpp = Tpp_1;        deltaz = deltaz_1;        z = z_1;    end        % Break condition    if abs(deltaz/z) < tol || T == 0, break; end        % Iterate    i = i + 1;end% Final calculationsC = C_func(z, tolz, K); % Bate 4.4-10S = S_func(z, tolz, K); % Bate 4.4-11oosqrtC = 1 / sqrt(C);y = r1 + r2 - A*(1-z*S) * oosqrtC; % Bate 5.3-9sqrty = sqrt(y);% Evaluate Lagrange parametersf = 1 - y/r1; % Bate 5.3-13g = A * sqrty*oosqrtmu;% Bate 5.3-14gdot = 1 - y/r2; % Bate 5.3-15% Evaluate velocity vectorsoog = 1/g;v1vec = oog*(r2vec - f*r1vec); % Bate 5.3-16v2vec = oog*(gdot*r2vec - r1vec); % Bate 5.3-17endfunction [T, Tp, Tpp] = tof_func(z, sqrtmutof, r1, r2, A, tolz, K)% Time of flight function% Evaluate S and CC = C_func(z, tolz, K); % Bate 4.4-10S = S_func(z, tolz, K); % Bate 4.4-11% S and C derivativesdCdz = dCdz_func(z, C, S, tolz, K);dSdz = dSdz_func(z, C, S, tolz, K);% Determine auxiliary variableooC = 1/C;oosqrtC = sqrt(ooC);y = r1 + r2 - A*(1-z*S) * oosqrtC; % Bate 5.3-9% Determine xsqrty = sqrt(y);x = sqrty*oosqrtC; % Bate 5.3-10xsq = x*x;xcu = xsq*x;% Compute sqrt(m) times Time of FlightT = xcu*S + A*sqrty - sqrtmutof; % Bate 5.3-12% First derivative of time of flightTp = xcu*(dSdz - 1.5*S*dCdz*ooC) ...    + 0.125*A*(3*S*sqrty*ooC + A/x); % Bate 5.3-23% Alternative formula for Tpdydz = 0.25*A*sqrt(C);dsqrtydz = 0.5/sqrty*dydz;dxdz = dsqrtydz*oosqrtC - 0.5*sqrty*oosqrtC*ooC*dCdz;% Second derivative of time of flightd2Sdz2 = d2Sdz2_func(z, C, S, dCdz, dSdz, tolz, K );d2Cdz2 = d2Cdz2_func(z, C, S, dCdz, dSdz, tolz, K );Tpp = ...    + 3*x^2*dxdz*( dSdz - 1.5*S*dCdz*ooC ) ...    + x^3*( ...        + d2Sdz2 ...        - 1.5*dSdz*dCdz*ooC ...        - 1.5*S*d2Cdz2*ooC ...        + 1.5*S*(d2Cdz2*ooC)^2) ...    + 0.125*A*(...        + 3*dSdz*sqrty*ooC ...        + 3*S*dsqrtydz*ooC ...        - 3*S*sqrty*ooC^2*dCdz ...        - A/x^2*dxdz);end