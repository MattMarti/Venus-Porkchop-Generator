function [v1vec, v2vec] = lambert(mu, r1vec, r2vec, tof, directtorbit)% Superior Lambert Algorithm to find velocity given time of flight% Computes velocity at both points of an orbit given the time of flight and% position vectors of the orbit.% % Based on the algorithm presented by Arora and Russel in "A Fast and% Robust Multiple Revolution Lambert Algorithm Using a Cosine% Tranformation"% % @arg% mu    - double%         Gravitational Constant% r1vec - 3 x 1 double matrix%         Start point Position vector% r2vec - 3 x 1 double matrix%         Destination point position vector% tof   - double%         Time of flight% % @return% v1vec - 3 x 1 double matrix%         Start point velocity vector% v2vec - 3 x 1 double matrix%         Destination point velocity vector% % @author: Matt Marti% @date: 2019-03-26global PORKCHOPCODE_LAMBERT_SQRT2if isempty(PORKCHOPCODE_LAMBERT_SQRT2)    PORKCHOPCODE_LAMBERT_SQRT2 = sqrt(2);end% Run test script if no argumentsif nargin == 0    Test_lambertend% Constantsconstantsepsilon = 1e-2;% Hardcode no extra rotationsN = 0;% Check inputsassert(length(r1vec) == 3, 'incorrect size of position vector');assert(length(r2vec) == 3, 'incorrect size of position vector');assert(tof >= 0, 'Negative time of flight');% Compute normsr1 = norm(r1vec);r2 = norm(r2vec);% Constants based on inputS = sqrt((r1 + r2)^3 / mu); % Eqn 26.2%% Initial guess%% Lambert solution with Halley's Method Iterationi = 0;ki = k0;while i < IMAX_PITERATION        % Time of flight error    [tki, tpki, tppki] = t_func(ki, S, tau, epsilon);    Lki = tki - tof; % Eqn 31        % Lagrange parameters    kitau = ki*tau;    f = 1 - (1-kitau)/r1; % Eqn 32    g = tau * (r1+r2)*sqrt(1-kitau); % Eqn 33    gdot = 1 - (1-kitau) / r2; % Eqn 34        % Velocities    v1vec = (r2vec - f * r1vec) / g; % Eqn 35    v2vec = (gdot*r2vec - r1vec) / g; % Eqn 36        % End condition    if Lki < 1e-6        break;    end        % Increment k    deltak = -Lki / (tpki - 0.5*Lki*tppki/tpki); % Eqn 40    ki = ki + deltak;endendfunction [t, tp, tpp] = t_func(k, S, tau, epsilon)% Time of flight function% Parametersktau = k*tau;c = (1 - ktau) / tau; % Eqn 37.3% Compute W parameter[W, Wp, Wpp] = W_func(k, epsilon);% Time of flightt = S * sqrt(1 - ktau) * (tau + (1 - ktau)*W); % Eqn 26.1% Time of flight derivativesctau = c*tau;sqrtctau = sqrt(ctau);Stau = S * tau;Stausqrtctau = Stau*sqrtctau;ooc = 1/c;oocsq = ooc*ooc;tp = - 0.5*t*ooc + Stausqrtctau*(Wp*c - W); % Eqn 37.1tpp = - 0.25*t*oocsq + Stausqrtctau*(W*ooc + c*Wpp - 3*Wp); % Eqn 37.2endfunction [W, Wp, Wpp] = W_func(k, epsilon)% W parameter function% Speed computation by saving the square root of 2 as a constantglobal PORKCHOPCODE_LAMBERT_SQRT2sqrt2 = PORKCHOPCODE_LAMBERT_SQRT2;% Hardcode N to 0N = 0;% Eqn 26m = 2 - k^2;% Determine orbit typeorbit_type_flag = 0;if -sqrt2 <= k && k < sqrt2 - epsilon    orbit_type_flag = 1; % Ellipcital Orbitelseif k > sqrt2 + epsilon    orbit_type_flag = 2; % Hyperbollic orbitelseif sqrt2 - epsilon <= k && k <= sqrt2 + epsilon    orbit_type_flag = 3; % Parabolic Orbitend% W, Wp, Wpp calculationswitch orbit_type_flag    case 1% Ellipcital Orbit        sgnk = sign(k);        W = ((1-sgnk)*pi + sgnk*acos(1-m) + 2*pi*N)/sqrt(m^3) - k/m; % Eqn 27.1        Wp = (-2 + 3*W*k)/m;        Wpp = (-2 + 3*W*k)/m;    case 2 % Hyperbollic orbit        W = -acosh(1-m)/sqrt(-m^3) - k/m; % Eqn 27.2        Wp = (-2 + 3*W*k)/(-m);        Wpp = (-2 + 3*W*k)/(-m);    case 3 % Parabolic Orbit        [W, Wp, Wpp] = Ws_func(k); % Eqn 27.3    otherwise        error('Orbit has undefined behavior!');endendfunction [Ws, Wsp, Wspp] = Ws_func(k)% Ws parameter function for parabolic orbit% Please God let me have copied these numbers right% Speed computation by saving the square root of 2 as a constantglobal PORKCHOPCODE_LAMBERT_SQRT2sqrt2 = PORKCHOPCODE_LAMBERT_SQRT2;% Coefficient vectorcvec = [ ...    + 1/3 * sqrt2;    - 1/5;    + 2/35 * sqrt2;    - 2/63;    + 2/231 * sqrt2;    - 2/429;    + 8/6435 * sqrt2;    - 8/12155;    + 8/46189 * sqrt2;    - 8/88179;    + 16/676039 * sqrt2;    - 16/1300075;    + 16/5014575 * sqrt2;    - 16/9694845;    + 128/300540195 * sqrt2    - 128/583401555;    + 128/2268783825 * sqrt2];% v parameter vectorv = k - sqrt2; % Eqn 28vvec = [...    0;    v;    v^2;    v^3;    v^4;    v^5;    v^6;    v^7;    v^8;    v^9;    v^10;    v^11;    v^12;    v^13;    v^14;    v^15;    v^16];% 1s derivative of v vectorvpvec = [...    0;    1;    2*v^1;    3*v^2;    4*v^3;    5*v^4;    6*v^5;    7*v^6;    8*v^7;    9*v^8;    10*v^9;    11*v^10;    12*v^11;    13*v^12;    14*v^13;    15*v^14;    16*v^15];% 2nd derivative of v vectorvppvec = [...    0;    0;    2;    2*3*v;    3*4*v^2;    4*5*v^3;    5*6*v^4;    6*7*v^5;    7*8*v^6;    8*9*v^7;    9*10*v^8;    10*11*v^9;    11*12*v^10;    12*13*v^11;    13*14*v^12;    14*15*v^13;    15*16*v^14];    % Eqn 28Ws = vvec'*cvec;% Derivatives of Eqn 28Wsp = vpvec'*cvec;Wspp = vppvec'*cvec;end