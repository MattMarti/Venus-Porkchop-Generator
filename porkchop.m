function [deltav, numlegs] = porkchop(data_Earth, data_Venus, plotflag, EorVflag)
%% PORKCHOP
% 
% Uses planetary ephemerides ([X,Y,Z,Vx,Vy,Vz] coordinates) to compute the
% necessary delta v to travel from a departure planet to a destination
% planet.
% 
% This script uses ephemerides generated by NASA JPL Solar System Dynamics
% webpage for planets to compute the delta v required.
% 
% Data generated at https://ssd.jpl.nasa.gov/horizons.cgi#top
% 
% Assumes two body mechanics for the spacecraft and Sun bodies.
% 
% INPUT
% data_from  - N x 7 double matrix
%              Ephemeris for departure planet
% data_to    - N x 7 double matrix
%              Ephemeris for arrival planet
% plotflag   - bool
%              whether to plot each transfer orbit as it is computed
% 
% OUTPUT
% deltav     - double matrix, nfrom x nto transfer orbit delta v matrix
% numlegs    - double matrix, number of burns during transfer
% 
% DEPENDENCIES
% transfer_deltav.m v 2018-11-08
% 
% @author: Matt Marti
% @date: 2018-03-18


%% Data

% Constants
global MAX_DAYS_TO_TRAVEL

max_seconds = MAX_DAYS_TO_TRAVEL*3600*24;


%% Calculate delta v

% Preallocate data
if EorVflag
    nfrom = size(data_Earth, 1);
    nto = size(data_Venus, 1);
    data_to = data_Venus;
    data_from = data_Earth;
else
    nfrom = size(data_Venus, 1);
    nto = size(data_Earth, 1);
    data_from = data_Venus;
    data_to = data_Earth;
end
deltav = zeros(nfrom, nto);
numlegs = zeros(nfrom, nto);

% Open progress bar
progbar = waitbar(0, 'Progress');

% Loop
for i = 1:nfrom
    
    % Reduce overhead by sampling array before loop
    data_from_i = data_from(i,:);
    
    % Decide if using parallel computation if not drawing plots
    if plotflag
        for j = 1:nto
            data_to_j = data_to(j,:);
            [deltav(i,j), numlegs(i,j)] ...
                = secondary_for_loop(data_from_i, data_to_j, EorVflag, plotflag, max_seconds);
        end
    else
        parfor j = 1:nto
            data_to_j = data_to(j,:);
            [deltav(i,j), numlegs(i,j)] ...
                = secondary_for_loop(data_from_i, data_to_j, EorVflag, plotflag, max_seconds);
        end
    end
    
    % Update progress bar
    waitbar(i/nfrom,progbar);
end

% Close progress bar
close(progbar);


end

function [deltav, numlegs] ...
    = secondary_for_loop(data_from_i, data_to_j, EorVflag, ...
      plotflag, max_seconds)

tof = data_to_j(1) - data_from_i(1);
if 0< tof && tof < max_seconds

    % Compute the delta v for one leg transfer
    try
        deltav_1 = transfer_deltav(data_from_i, data_to_j, EorVflag, plotflag, 1);
    catch
        deltav_1 = inf;
    end

    % Compute the delta v for two leg transfer
    try
        deltav_2 = transfer_deltav_2step(data_from_i, data_to_j, EorVflag, plotflag, 2);
    catch
        deltav_2 = inf;
    end

    % Decide if one leg or two leg transfer burn
    if deltav_1 < deltav_2
        deltav = deltav_1;
        numlegs = 1;
    else
        deltav = deltav_2;
        numlegs = 2;
    end
else
    deltav = inf;
    numlegs = 0;
end
end