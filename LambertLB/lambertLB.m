function [v1vec, v2vec] = lambertLB(mu, r1vec, r2vec, tof, hyperflag, ccwflag)% Superior Lambert Algorithm to find velocity given time of flight% Computes velocity at both points of an orbit given the time of flight and% position vectors of the orbit.% % Based on the algorithm in Lancaster and Blanchard [LB] "A Unified Form of% Lambert's Theorem", 1969, and the paper by Lancaster, Blanchard, and% Devaney "A Note on Lambert's Theorem", 1966.% % Also uses the DerAstrodynamics [DA] algorithm for determining whether the% transfer orbit has a change in true anomoly of greater than 180 degrees.% This function assumes planetary orbits are counter-clockwise% % @arg% mu        - double%             Gravitational Constant% r1vec     - 3 x 1 double matrix%             Start point Position vector% r2vec     - 3 x 1 double matrix%             Destination point position vector% tof       - double%             Time of flight% hyperflag - bool%             True: Sets initial guess to approximately a hyperbolic orbit%             False: Initial guess is elliptical% ccwflag -   bool (optional)%             Counter-clockwise orbit flag. True will cause the function to%             compute a counter-clockwise transfer orbit.%             Defaults to true if not specified.% % @return% v1vec     - 3 x 1 double matrix%             Start point velocity vector% v2vec     - 3 x 1 double matrix%             Destination point velocity vector% % @author: Matt Marti% @date: 2019-03-26% Define square root of 2global PORKCHOPCODE_LAMBERT_SQRT2if isempty(PORKCHOPCODE_LAMBERT_SQRT2)    PORKCHOPCODE_LAMBERT_SQRT2 = sqrt(2);endsqrt2 = PORKCHOPCODE_LAMBERT_SQRT2;% Run test script if no argumentsif nargin == 0    Test_lambertendif nargin < 5    hyperflag = 0;endif nargin < 6    ccwflag = 1; % Defaultend% Constantsconstantsepsilon = 1e-2;% Hardcode no extra rotationsm = 0;% Check inputsassert(length(r1vec) == 3, 'incorrect size of position vector');assert(length(r2vec) == 3, 'incorrect size of position vector');assert(tof >= 0, 'Negative time of flight');% Compute normsr1 = norm(r1vec);r2 = norm(r2vec);% Compute geometry parameteralpha = dot([0;0;1], cross(r1vec,r2vec)); % [DA] clockwise orbitdotr1r2 = dot(r1vec,r2vec);cosdelnu = dotr1r2 / (r1*r2);delnu = acos(cosdelnu);DM = 1;if ccwflag % If counter-clockwise    if alpha < 0        delnu = 2*pi - delnu;        DM = -1;    endelse % Clockwise transfer    if alpha > 0        delnu = 2*pi - delnu;        DM = -1;    endend% Equation 1c = sqrt( r1^2 + r2^2 - 2*dotr1r2);% Equation 1 from Note on Lamberts = 0.5*(r1 + r2 + c);oos = 1/s;q = sqrt(r1*r2)*oos*cos(0.5*delnu); % [LB], Eqn 19% T = sqrt(8*mu*oos)*tof*oos; % [LB], Eqn 20%% Initial guess% Not the real way to initialize the guess, but the algorithm is relatively% robustif hyperflag    x0 = 1.5;else    x0 = 0;end%% Lambert solution with Halley's Methodi = 0;x = x0;while i < IMAX_LAMBERT        % Compute Time of flight and derivatives    dx = 1e-6;    [T, Tp, z] = tof_func(x, q, m);    [~, Tp_h, ~] = tof_func(x+dx, q, m);    [~, Tp_l, ~] = tof_func(x-dx, q, m);    Tpp = 0.5*(Tp_h - Tp_l)/dx;        % End condition    if abs(T - tof) < PRECISION_LAMBERT        break;    end        % Increment x    deltax = - 2*T*Tp / (Tp^2 - T*Tpp);    x = x + deltax;        % Iterate    i = i + 1;end% Compute rate of changer1dot = sqrt(2*mu*s)*(q*z*(s-r1) - x*(s-r2))/(c*r1);r2dot = sqrt(2*mu*s)*(x*(s-r1) - q*z*(s-r2))/(c*r2);% Some coefficients% Velocity calculationvr1vec = (r1dot/r1)*r1vec;vtheta1vec = c1*r1vec + c2*r2vec;% Lagrange coefficientsf = 1 - (1-kitau)/r1; % Eqn 32g = tau * (r1+r2)*sqrt(1-kitau); % Eqn 33gdot = 1 - (1-kitau) / r2; % Eqn 34% Velocitiesv1vec = (r2vec - f * r1vec) / g; % Eqn 35v2vec = (gdot*r2vec - r1vec) / g; % Eqn 36endfunction [T, Tp, z] = tof_func(x, q, m)constants;K = q^2;% Compute parameter E and it's dependentsE = x^2 - 1;% Compute parametersif abs(x - 1) < PARABOLIC_TOLERANCE_LAMBERT % Close to parabolic orbit    T = sigma_func(-E) - q*K*sigma_func(-K*E);    Tp = 2*x*( q*K^2*sigmap_func(-K*E) - sigmap_func(-E) );else % Not close to parabolic orbit    y = sqrt(abs(E));    z = sqrt(1 + K*E);    f = y*(z - q*x);    g = x*z - q*E;    if E < 0        lambda = atan(f/g);        d = m*pi + lambda;    else        d = log(f + g);    end    % Compute time of flight of guess orbit    T = 2*(x - q*z - d/y) / E;    Tp = (4 - 4*q*K*x/z - 3*x*T)/E;endendfunction s = sigma_func(u)sqrtu = sqrt(u);s = 2*(asin(sqrtu) - sqrtu*sqrt(1-u)) / (sqrtu^3);endfunction s = sigmap_func(u)du = 1e-6;s = 0.5*(sigma_func(u+du) - sigma_func(u-du)) / du;end